name: Python Unit Tests
on:
  pull_request:
    types: [labeled]
  workflow_dispatch:

env:
  PYTHONWARNDEFAULTENCODING: 'true'
  PY_COLORS: 1
  # Ensure this exactly matches the name: field in sync.yml OR the filename sync.yml
  WORKFLOW_FILE: "Sync Test DB with Prod"

permissions:
  contents: read
  pull-requests: write
  deployments: write
  actions: read # Needed to read artifacts from other workflow runs

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  lint:
    if: github.event.label.name == 'ci' || github.event_name == 'workflow_dispatch'
    name: Lint and Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version-file: 'pyproject.toml'
          allow-prereleases: true

      - name: Install Dependencies
        run: |
          pip install --upgrade pip poetry
          poetry install --with dev

      - name: Run Ruff Linting
        run: poetry run ruff check .

  test:
    if: github.event.label.name == 'ci' || github.event_name == 'workflow_dispatch'
    name: "Build and Test on ${{ matrix.os }}" # Removed python version as it's from pyproject.toml
    needs: lint
    runs-on: "${{ matrix.os }}-latest"

    services:
      postgres:
        image: postgres:15 # Using a specific version is often better
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        # Ensure the service is healthy before tests run
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    strategy:
      matrix:
        os:
          - Ubuntu
      fail-fast: true

    defaults:
      run:
        shell: bash

    steps:
      - name: Display Current Test Matrix
        run: echo '${{ toJSON(matrix) }}'

      - name: Checkout PR Code
        uses: actions/checkout@v4
        # Ensure we check out the correct code for PRs
        with:
          ref: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.ref }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version-file: 'pyproject.toml'
          allow-prereleases: true

      - name: Get Full Python Version
        id: full-python-version
        run: echo "version=$(python -c "import sys; print('-'.join(str(v) for v in sys.version_info))")" >> $GITHUB_OUTPUT

      - name: Bootstrap Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python - -y

      - name: Update PATH
        # No need for OS check, $HOME/.local/bin is standard on Linux runners
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Configure Poetry
        run: poetry config virtualenvs.in-project true

      - name: Setup Poetry Cache (using UV)
        uses: actions/cache@v4
        id: cache # Changed id to avoid conflict with setup-python cache name
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ steps.full-python-version.outputs.version }}-${{ hashFiles('**/poetry.lock') }}

      - name: Ensure Cache is Healthy
        if: steps.cache.outputs.cache-hit == 'true'
        run: |
          # Use timeout from coreutils if available, otherwise use perl fallback
          [ "$(command -v timeout)" ] || function timeout() { perl -e 'alarm shift; exec @ARGV' "$@"; }
          timeout 10s poetry run pip --version || rm -rf .venv

      - name: Check lock file
        run: poetry check --lock

      - name: Install Dependencies
        run: poetry install --with dev

      - name: Install GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y gh

      - name: Configure GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh auth login --with-token <<< "$GH_TOKEN"

      - name: Debug GitHub CLI Auth Status
        run: gh auth status

      - name: Find Latest Successful Run ID
        id: find_run
        run: |
          echo "Looking for successful runs of workflow: $WORKFLOW_FILE"
          # Use --jq for cleaner extraction and handle potential nulls/errors
          run_id=$(gh run list --workflow="$WORKFLOW_FILE" --limit 20 --json databaseId,conclusion --jq '.[] | select(.conclusion=="success") | .databaseId' | head -n1)

          if [ -z "$run_id" ]; then
            echo "::error::No successful run found for workflow '$WORKFLOW_FILE'."
            exit 1
          else
            echo "Found successful run_id: $run_id"
            echo "run_id=$run_id" >> $GITHUB_OUTPUT
          fi

      - name: Download Latest Sync Artifact (DB Dump)
        run: |
          echo "Attempting to download artifact 'test-db-dump' from run ${{ steps.find_run.outputs.run_id }}"
          # Use GH_TOKEN for authentication if needed, though gh auth login should suffice
          # GH_TOKEN=${{ secrets.GITHUB_TOKEN }} gh run download ...
          gh run download "${{ steps.find_run.outputs.run_id }}" -n test-db-dump --dir .
          echo "Listing files after DB dump download attempt:"
          ls -l dump.sql # Check if dump.sql exists

      - name: Load DB Dump If Exists
        run: |
          if [ -f dump.sql ]; then
            echo "Restoring database from dump.sql"
            # Ensure postgres service is ready (redundant with service health check, but safe)
            # while ! pg_isready -h localhost -p 5432 -q; do sleep 1; done
            PGPASSWORD=postgres psql -h localhost -U postgres -d test_db < dump.sql
          else
            # Make this an error because the download should have worked
            echo "::error::Database dump file 'dump.sql' not found after download attempt."
            exit 1
          fi

      - name: Download Env Vars Artifact
        run: |
          echo "Attempting to download artifact 'env-vars' from run ${{ steps.find_run.outputs.run_id }}"
          gh run download "${{ steps.find_run.outputs.run_id }}" -n env-vars --dir .
          echo "Listing files after env-vars download attempt:"
          ls -l env_vars.env # Check if env_vars.env exists

      - name: Load Environment Variables and Run Tests
        run: |
          if [ ! -f env_vars.env ]; then
            # Make this an error because the download should have worked
            echo "::error::Environment variables file 'env_vars.env' not found after download attempt."
            exit 1
          fi
          echo "Sourcing environment variables..."
          set -o allexport
          # Use . instead of source for better POSIX compatibility
          . ./env_vars.env
          set +o allexport
          echo "Running tests..."
          poetry run pytest -v
